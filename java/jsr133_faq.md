# JSR 133 (Java Memory Model) FAQ

原文点[这里](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html)

主要内容：

1. 何为内存模型？
2. 其他语言，比如 C++，有内存模型吗？
3. JSR 133 是做什么的？
4. 重排序意味着什么？
5. 老内存模型存在什么问题？
6. 错误的同步意味着什么？
7. 同步是做什么的？
8. 为何 `final` 变量有时似乎改变了自己的值？
9. `final` 变量在 JMM 下如何工作？
10. `volatile` 是做什么的？
11. 新内存模型修复 *双重检查加锁* 的问题了吗？
12. 如果要写虚拟机该怎么做？
13. 为何要关心内存模型？

## 何为内存模型？

多处理器系统中，处理器通常有 **多级缓存**，通过加快数据访问速度（因为缓存更靠近处理器，所以速度更快）、减轻内存总线压力，缓存大大提升了处理器性能，但也带来了新的问题。比如，若两个处理器同时访问同一内存地址的内容，将发生什么？什么情况下它们会获取相同的数据？

在处理器层次，内存模型定义了必要、足够的条件，使其他处理器 **对内存的写操作** 对当前处理器 **可见**，并且当前处理器的写操作对其他处理器也是可见的。

有的处理器采用 **强内存模型**，即保证所有处理器在 **任意时刻** 对 **同一内存地址** 获取 **相同的值**。

有的采用 **弱内存模型**，即需要调用 **特殊指令**（称为 `memory barriers`）来 **flush**、**invalidate** 当前处理器的 **本地缓存**，以便当前处理器可以看到其他处理器的写、其他处理器也可以看到当前处理器的写。`memory barriers` 一般在 `lock` `unlock` 时发生，且对使用高级语言的程序员不可见。

在强内存模型下写程序要容易点，因为不需要 `memory barriers`。然而即使在 **最严格** 的内存模型下，也需要 `memory barriers`。最近的处理器设计鼓励使用若内存模型，因为通过 **放松** 对 **缓存一致性** 的要求，可以获取更大的跨处理器扩展性。

为了让 **写操作** 对其他线程可见，还需要考虑编译器对代码的 **重排序**。

比如，编译器可能认为将 **写操作** 放到程序最后会提升效率（前提是这不会改变程序语义），此时编译器 **延迟** 了写操作，其他线程只有在该操作执行后才能看到写的结果。

更可怕的是，写操作可以被 **提前**，此时其他线程在程序没有执行到写操作之前，就能看到写操作的结果。

为了获取更高性能，在 **内存模型** 限制内，允许编译器、运行时、硬件对代码 **执行顺序** 进行优化，所以会出现上面的情况。

```
class Reordering {
  int x = 0;
  int y = 0;

  public void writer() {
    // 1
    x = 1;
    // 2
    y = 2;
  }

  public void reader() {
    // 3
    int r1 = y;
    // 4
    int r2 = x;
  }
}
```

假设两个线程并发执行上述代码，且读取 `y` 时得到 2。因为对 `y` 的写在对 `x` 写之后，所以程序员可能会假设读取 `x` 时肯定获取 1。然而代码可能被重排序，所以执行顺序可能是 2 3 4 1，此时 `r1` 为 2，`r2` 为 0。

Java 内存模型描述了在多线程代码中，什么行为是合法的、进程应该怎样通过 **共享内存** 进行通信。JMM 描述了程序中的 **变量** 与从内存、寄存器中获取、存储变量的底层细节之间的关系。

Java 提供了 `volatile` `final` `synchronized` 等关键字，帮助程序员告诉编译器，该程序对 **并发** 的要求。JMM 定义了 `volatile` `synchronized` 的行为，保证正确使用 `synchronized` 的代码在所有处理器上都能正确运行。

## 其他语言，比如 C++，有内存模型吗？

多数其他语言，比如 C、C++，没有对多线程的直接支持。这些语言对重排序的限制依赖于使用的 **线程库**（比如 `pthreads`），使用的 **编译器**，以及代码运行的 **平台**。（即没有语言层面的支持，依赖外部设施）

## JSR 133 是做什么的？

自 1997 年以来，陆续发现了 JMM 的几个严重缺陷，这些缺陷或允许出现 `confusing behaviors`（比如 `final` 变量改变了自己的值），或损坏了编译器执行普通优化的能力。

JMM 目标宏大，第一次有语言试图包含一个能在不同架构上提供 **一致性并发语义** 的内存模型。但定义一致、符合直觉的内存模型比预期困难的多，JSR 133 定义了一个新的内存模型，为了修复原有模型的缺陷，`final` `volatile` 的语义 **需要修改** 。

JMM 的完整文档可以在[这里](http://www.cs.umd.edu/users/pugh/java/memoryModel)获取，即使 `synchronization` 这样简单的概念在文档中都有非常复杂的描述，幸运的是并不需要通读该文档。

























个任务
