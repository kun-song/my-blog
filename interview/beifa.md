# 倍发科技

大约 2017 年 11 月左右浏览拉钩的时候，发现成都有家叫倍发科技的公司在招 Scala 程序员，就投了一发。当时 Scala 其实刚刚入门，小红书也不过看到了第五章左右，权当试试水。

后来首先是电话面试，开始是项目介绍，后来面试官问了一些问题，最后发了一份题目，要求一周内完成，因为工作太忙了，题目没有做，也就没有下文了。

## 面试题目

### 1. 乐观锁、悲观锁区别

关于乐观锁、悲观锁的基本介绍，可以参考该 [文章](http://www.hollischuang.com/archives/934)。

乐观锁和悲观锁其实并非 **特定实现**，而是一种 **思想**，可以有多种实现方式：

* 乐观锁（之所以叫乐观锁，是它对 **并发写** 持乐观预期，即认为并发写操作 **很少** 发生）
  + 实现方式 1
    - 在数据库表中添加 **版本号** 字段，读表时获取该字段，处理完业务逻辑，需要 **更新** 表时，验证数据库中该字段的当前值是否与前面读取的值一致，若一致，则更新表，并将版本号 + 1；若不一致，则不更新。
  + 实现方式 2
    - 实现 **时间戳字段** 替代版本号，其他实现相同；
* 悲观锁
  + 一般利用 **数据库锁** 实现；
  + 读取表时，对该表加锁，其他读取操作都需要 **等待**；

两者区别总结如下：

1. 实现方式
  * 乐观锁：程序手动实现，与数据库无关；
  * 悲观锁：利用数据库本身的锁机制；
2. 基本假设
  * 乐观锁：假定 **并发写** 很少，大多是并发读，若用悲观锁，则会导致 **并发读** 被禁止，偶尔的并发写失败使用 **失败重试** 策略恢复；
  * 悲观锁：假定 **并发写** 非常频繁，此时失败重试 **成本太高**，所以排队等待更加合理；
3. 响应速度
  * 乐观锁：响应速度快，因为 **无需排队**，所以无论成功、失败，都能立即完成；
  * 悲观锁，响应速度慢，因为需要 **排队** 获取锁，一般用 **排他锁** 实现，所以 **读操作** 也要排队等待；
4. 死锁
  * 乐观锁：不会死锁；
  * 悲观锁：可能死锁；

### 2. `ConcurrentHashMap` 使用场景

可以将 Java 的容器分为两类：

* 同步容器：
  + `Vector` `HashTable`
  + 使用 `Collections.synchronizedXxx` 创建的封装器类
* 并发容器：Java 5 新增加的容器类型，在 `java.util.concurrent` 中；

#### 同步容器的局限

为了实现 **线程安全**，同步容器将所有对 **容器状态** 的访问操作都 **串行化**（通过 `synchronized` 方法），这固然可以实现安全，但代价是 *严重降低并发性*，因为当个线程竞争容器的锁时，其吞吐量将严重降低。

针对多线程并发访问的场景，Java 5 引入并发容器，用以 **取代** 同步容器：

* `ConcurrentHashMap` 取代 `HashTable` 和 `synchronizedMap`
* `CopyOnWriteArrayList` 在主要操作为 **遍历** 时取代同步 `List`
* `ConcurrentSkipListMap` 取代同步 `SortedMap`
* `ConcurrentSkipListSet` 取代同步 `SortedSet`

#### `ConcurrentHashMap`

`HashTable` 加锁方式为：

* 只有一个全局锁，即监视器锁
* 对每个 `public` 方法加锁

这种加锁策略的结果是，同一时间点上，只有一个线程可以访问容器，并发读非常低。

`ConcurrentHashMap` 也是基于 **散列** 的 `Map` 实现，与 `HashTable` 不同，其加锁粒度很细，称之为 **分段锁**，该机制下：

* **任意数量** 的读线程，可以并发访问 `ConcurrentHashMap`
* 读线程、写线程，可以并发访问 `ConcurrentHashMap`
* **一定数量** 的写线程，可以 **并发修改** `ConcurrentHashMap`

因此 `ConcurrentHashMap` 在 *并发访问* 环境下将实现更高的吞吐量，而在 *单线程* 环境中，只会损失很小的性能。

另外 `ConcurrentHashMap` 不会抛出`ConcurrentModificationException` 异常，因此不需要在迭代过程中对容器加锁。

`ConcurrentHashMap` 返回的迭代器具有 **弱一致性**，并非及时失败，因此可以容忍 **并发修改**，造成的结果是，一些需要在整个 `Map` 上进行计算的方法，比如 `size` 和 `isEmpty`，这些方法的 **语义** 被微弱减弱，以反映容器的并发特性：

* 由于 `size` 返回的结果在计算时可能已经 **过期** 了，因此实际返回的只是一个 **估计值**；
* 事实上，`size` 和 `isEmpty` 这类方法在 **并发环境** 下 **用处很少**，因为他们的返回值总在 **不停变化**，因此这些方法的 *需求被弱化* 了，以换取对其他更重要操作的性能优化，比如 `get` `put` `containsKey` 等等；
